---
title: 微信支付
date: 2018-06-14 15:03:52
tags:
---

# 微信扫码支付 模式二
## 获取二维码
```java

    @RequestMapping("code2/url")
    public R code_url(@RequestBody PfOrderPayRecordEntity orderPay){

        String orderDate = DateUtils.format(new Date(),"yyyyMMddHHmmss");
        String orderId = orderDate+idService.getTypeId("wechatpay",10);
        // 统一下单文档地址：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_1
        Map<String, String> params = new HashMap<String, String>();
        params.put("appid", PayConfigUtil.readConfig("appId"));
        params.put("mch_id", PayConfigUtil.readConfig("mchId"));
        params.put("body", "商城在线支付");

        // 商品ID trade_type=NATIVE，此参数必传。此id为二维码中包含的商品ID，商户自行定义。
        params.put("product_id", orderPay.getOrderTime()+"");
        // 商户订单号 商户系统内部的订单号,32个字符内、可包含字母, 其他说明见商户订单号
        params.put("out_trade_no", orderId);
        params.put("total_fee", "1");// 总支付金额
        //params.put("total_fee", new BigDecimal(100).multiply(orderPay.getRecordPayment())+"");
        params.put("detail", "这是一个商品详情");

        String ip = IpUtil.getRealIp(getRequest());
        if (StringUtils.isBlank(ip)) {
            ip = "127.0.0.1";
        }

        params.put("spbill_create_ip", ip);
        params.put("trade_type", PayApi.TradeType.NATIVE.name());
        params.put("nonce_str", System.currentTimeMillis() / 1000 + "");
        //回调地址 支付结果处理
        String notify_url = PayConfigUtil.readConfig("notify_url").replace("*",SysService.getDomainName());
        params.put("notify_url", notify_url);
        //获取参数签名
        String sign = PayUtil.createSign(params, PayConfigUtil.readConfig("payKey"));
        params.put("sign", sign);
        logger.info(params.toString());
        //通过接口生成动态二维码
        String xmlResult = PayApi.pushOrder(params);
        System.out.println(xmlResult);
        Map<String, String> result = PayUtil.xmlToMap(xmlResult);
        String return_code = result.get("return_code");
        String return_msg = result.get("return_msg");
        if (StringUtils.isBlank(return_code) || !"SUCCESS".equals(return_code)) {
            throw new RRException(return_msg);
        }
        String result_code = result.get("result_code");
        if (StringUtils.isBlank(result_code) || !"SUCCESS".equals(result_code)) {
            throw new RRException(return_msg);
        }
        // 以下字段在return_code 和result_code都为SUCCESS的时候有返回
        String prepay_id = result.get("prepay_id");
        // trade_type为NATIVE是有返回，可将该参数值生成二维码展示出来进行扫码支付
        String code_url = result.get("code_url");

        orderPay.setPayType(PayTypeEnum.WECHAT_PAYMENT.getIndex());
        orderPay.setOnlinePayOrder(orderId);

        redisService.set("wechat.pay."+orderId,orderPay);

        return R.ok().put("url",code_url).put("out_trade_no",orderId);
    }
```

## 扫描二维码回调处理

```java

    @Autowired
    private SimpMessagingTemplate template;

    /**
     * 微信支付成功异步通知 不止一次通知
     * @param response
     * @param request
     */
    @RequestMapping("/notify")
    public void notify(HttpServletResponse response, HttpServletRequest request){
            String xmlMsg = HttpUtils.readData(request);
            Map<String, String> params = PayUtil.xmlToMap(xmlMsg);
            logger.info(xmlMsg);
            String result_code  = params.get("result_code");
            String orderId      = params.get("out_trade_no");
            // 总金额
            String totalFee     = params.get("total_fee");
             if(PayUtil.verifyNotify(params, PayConfigUtil.readConfig("payKey"))){

                if (("SUCCESS").equals(result_code)) {
                 //异步通知
                 template.convertAndSend("/topic/wechat/"+orderId,"SUCCESS")；
               }
            }
       }

```

## websocket配置文件
```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {
    @Override
    public void registerStompEndpoints(StompEndpointRegistry stompEndpointRegistry) {
        stompEndpointRegistry.addEndpoint("/wechat/endpointSang").setAllowedOrigins("*").withSockJS();
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker("/topic");
    }
}
```


## 页面显示

```html

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link type="image/x-icon" rel="shortcut icon" href="favicon.ico" />
    <title>商城</title>
</head>
<body class="hold-transition login-page">
<div class="login-box" id="rrapp" v-cloak>
    <div class="login-logo">
        <b>商城 (支付测试)</b>
        <b>订单号：</b><div >{{prepay_id}}</div>
    </div>

    <div id="output"></div>
    <div>{{SUCCESS}}</div>

</div>
<script src="libs/jquery.min.js"></script>
<script src="libs/jquery.qrcode.min.js"></script>
<script src="plugins/jqgrid/jquery.jqGrid.min.js"></script>
<script src="libs/vue.min.js"></script>
<script src="libs/bootstrap.min.js"></script>
<script src="libs/app.js"></script>
<script src="js/common.js"></script>
<script src="https://cdn.bootcss.com/sockjs-client/1.1.4/sockjs.min.js"></script>
<script src="https://cdn.bootcss.com/stomp.js/2.3.3/stomp.min.js"></script>
<script type="text/javascript">


    var vm = new Vue({
        el:'#rrapp',
        data:{
            te:{
                orderId:"1234567899871",
                totalFee:"1"
            },

            prepay_id:"",

            SUCCESS:""
        },
        created(){
            var _this = this;
            $.ajax({
                data:JSON.stringify(_this.te),
                dataType: "json",
                type: "POST",
                contentType: "application/json;charset=UTF-8",
                url: baseURL + "wechat/code2/url",
                success: function(r){
                    if(r.code == 0){
                        console.log("============"+r.url)
                        _this.prepay_id = r.out_trade_no;

                        jQuery('#output').qrcode(r.url);

                        var socket = new SockJS('/shop/wechat/endpointSang');

                        stompClient = Stomp.over(socket);
                        stompClient.connect({}, function (frame) {
                            stompClient.subscribe('/topic/wechat/'+r.out_trade_no, function (response) {

                                console.log(1111111111,response)
                                if (response.body=="SUCCESS"){
                                    vm.SUCCESS = "支付成功";
                                }

                                if (stompClient != null) {
                                    stompClient.disconnect();
                                }
                            })
                        });
                    }else{
                        vm.errorMsg = r.msg;
                    }
                }
            });
        },

    });
</script>
</body>
</html>


```
